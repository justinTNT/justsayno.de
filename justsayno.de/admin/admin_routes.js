// Generated by CoffeeScript 1.6.2
(function() {
  var fs, ft, mongoose, schemetools, sys, temptools, _,
    __hasProp = {}.hasOwnProperty;

  mongoose = require("mongoose");

  _ = require("underscore");

  fs = require("fs");

  sys = require("util");

  require("./schema/admin");

  require("./schema/taxon");

  ft = require("../fieldtools");

  temptools = require("../temptools");

  schemetools = require("../schemetools");

  module.exports = function(env, appenv, admdb) {
    var Fields, STRstatdirlist, Taxon, admins, authenticate, finishFileLoad, onlyAdmVox, onlyAdminCanAdminAdmin, requiresLogin, statdirlist;

    admins = admdb.model("justsayAdmins");
    Fields = admdb.model("justsayAdminFields");
    Taxon = admdb.model("taxon");
    finishFileLoad = function(from, to, count, cb) {
      return fs.stat(to, function(err, stats) {
        var i;

        i = void 0;
        if (!err) {
          if (count) {
            while (to.charAt(to.length - 1) !== "_") {
              to = to.substr(0, to.length - 1);
            }
            to = to.substr(0, to.length - 1);
          }
          to = "" + to + "_" + (count.toString());
          count++;
          return finishFileLoad(from, to, count, cb);
        } else {
          fs.rename(from, to);
          while ((i = to.indexOf("/")) >= 0) {
            to = to.substr(i + 1);
          }
          return cb(to);
        }
      });
    };
    STRstatdirlist = function(path, files, stats, cb) {
      var fn;

      if (!files.length) {
        return cb(stats);
      }
      fn = files.shift();
      return fs.stat(path + fn, function(err, s) {
        var mt;

        if (!err) {
          mt = JSON.stringify(s.mtime);
          stats.push({
            filelist_name: fn,
            filelist_date: mt,
            filelist_size: s.size
          });
        }
        return STRstatdirlist(path, files, stats, cb);
      });
    };
    statdirlist = function(path, files, stats, cb) {
      var fn;

      if (!files.length) {
        return cb(stats);
      }
      fn = files.shift();
      return fs.stat(path + fn, function(err, s) {
        if (!err && s.isFile()) {
          stats.push({
            filelist_name: fn,
            filelist_date: s.mtime,
            filelist_size: s.size
          });
        }
        return statdirlist(path, files, stats, cb);
      });
    };
    authenticate = function(name, pass, appname, cb) {
      return admins.find({
        appname: appname,
        login: name
      }, function(err, docs) {
        var o;

        if (err) {
          throw err;
        }
        if (docs.length === 0 || docs[0].passwd !== pass) {
          return cb();
        }
        o = docs[0].toObject();
        delete o.passwd;
        return cb(o);
      });
    };
    requiresLogin = function(req, res, next) {
      if (!req.session || req.session.user) {
        return next();
      }
      return res.redirect("/sessions/new");
    };
    /*
    	# ROUTE MIDDLEWARE
    */

    onlyAdminCanAdminAdmin = function(req, res, next) {
      var err, i, sch;

      if (req.params.table === "admin") {
        req.params.theTable = admins;
        if (req.session.user.login !== "admin") {
          return next(new Error("Unauthorised access of admin tables"));
        }
      } else {
        sch = null;
        try {
          sch = require("../../apps/" + env.targetapp + "/schema/" + req.params.table);
        } catch (_error) {
          err = _error;
          for (i in appenv.plugins) {
            if (!sch) {
              try {
                sch = require("../../common/" + appenv.plugins[i] + "/schema/" + req.params.table);
              } catch (_error) {}
            }
          }
        }
        req.params.theTable = env.targetenv.db.model(sch.name);
        return next();
      }
    };
    onlyAdmVox = function(req, res, next) {
      if (req.session.user.login === "admin") {
        return next();
      }
      return next(new Error("Unauthorised access of vocab tables"));
    };
    /*
    	# ckeditor paths
    */

    env.app.get("/ck_browse", requiresLogin, function(req, res) {
      var topath;

      topath = process.cwd() + ("/apps/static/public/" + env.targetapp + "/admcke/");
      return fs.readdir(topath, function(err, files) {
        var browsebase, temps, url;

        temps = [
          {
            selector: "#maintab",
            filename: "filebrowse.jade"
          }
        ];
        browsebase = [
          {
            selector: "#boilerplate-container",
            filename: "browse.jade"
          }
        ];
        url = "http://" + env.staticurl + "/" + env.targetapp + "/admcke/";
        return STRstatdirlist(topath, files, [], function(stats) {
          return env.respond(req, res, browsebase, temps, {
            hidden_url: url,
            file_list_file: stats
          }, "browse.tpl");
        });
      });
    });
    env.app.post("/ck_upload", requiresLogin, function(req, res) {
      var funcNum, topath, url;

      topath = process.cwd() + ("/apps/static/public/" + env.targetapp + "/admcke/");
      funcNum = req.param("CKEditorFuncNum");
      url = "http://" + env.staticurl + "/" + env.targetapp + "/admcke/";
      return finishFileLoad(req.files.upload.path, topath + req.files.upload.name, 0, function(to) {
        res.write("<script type='text/javascript'> window.parent.CKEDITOR.tools.callFunction(" + funcNum + ", '" + url + req.files.upload.name + "', '');</script>");
        return res.end();
      });
    });
    env.app.get("/list", requiresLogin, function(req, res, next) {
      return Fields.distinct("table", {
        appname: env.targetapp
      }, function(err, docs) {
        var all_objs, j, temps, which_fields;

        if (err) {
          throw err;
        }
        if (req.session.user.login !== "admin") {
          j = 0;
          while (j < docs.length) {
            if (docs[j] === "admin") {
              delete docs[j];
            } else {
              if (!req.session.user[docs[j]]) {
                delete docs[j];
              }
            }
            j++;
          }
        }
        which_fields = [
          "table", {
            table: 'table.href'
          }
        ];
        all_objs = {
          tabitem: ft.translateFields(_.compact(docs), which_fields)
        };
        temps = [
          {
            selector: "#maintab",
            filename: "listall.jade"
          }, {
            selector: "#theschemes",
            filename: "eachtab.jade"
          }
        ];
        if (req.session.user.login === "admin") {
          temps.push({
            selector: "#vocablink",
            filename: "vocablink.jade"
          });
        }
        return env.respond(req, res, env.basetemps, temps, all_objs);
      });
    });
    env.app.get("/vocabs", requiresLogin, onlyAdmVox, function(req, res, next) {
      return Taxon.distinct("vocab", {
        appname: env.targetapp
      }, function(err, docs) {
        var all_objs, which_fields;

        if (err) {
          throw err;
        }
        which_fields = ["vocab"];
        all_objs = ft.translateFields(docs, which_fields);
        return env.respond(req, res, null, null, all_objs);
      });
    });
    env.app.get("/vocab/:vocab", requiresLogin, onlyAdmVox, function(req, res, next) {
      return Taxon.find({
        appname: env.targetapp,
        vocab: req.params.vocab
      }, function(err, docs) {
        var all_objs, which_fields;

        if (err) {
          throw err;
        }
        which_fields = ["taxon"];
        all_objs = ft.translateFields(docs, which_fields);
        return env.respond(req, res, null, null, all_objs);
      });
    });
    env.app.get("/vox_n_tax", requiresLogin, function(req, res, next) {
      return Taxon.find({
        appname: env.targetapp
      }).sort("vocab").exec(function(err, docs) {
        var all_objs, i, snd_obj, v, which_fields;

        if (err) {
          throw err;
        }
        which_fields = ["vocab", "taxon"];
        snd_obj = {};
        all_objs = ft.translateFields(docs, which_fields);
        for (i in all_objs) {
          v = all_objs[i].vocab;
          if (!snd_obj[v]) {
            snd_obj[v] = [];
          }
          if (all_objs[i].taxon && all_objs[i].taxon.length) {
            snd_obj[v].push(all_objs[i].taxon);
          }
        }
        return env.respond(req, res, null, null, snd_obj);
      });
    });
    env.app.post("/remove_voc", requiresLogin, onlyAdmVox, function(req, res, next) {
      var vox;

      vox = JSON.parse(req.body.id_array);
      Taxon.remove({
        vocab: {
          $in: vox
        }
      }, function(err, docs) {
        if (err) {
          throw err;
        }
      });
      return res.send("OK");
    });
    env.app.post("/remove_voc/:vocab", requiresLogin, onlyAdmVox, function(req, res, next) {
      var tax;

      tax = JSON.parse(req.body.id_array);
      Taxon.remove({
        vocab: req.params.vocab,
        taxon: {
          $in: tax
        }
      }, function(err, docs) {
        if (err) {
          throw err;
        }
      });
      return res.send("OK");
    });
    env.app.post("/add_voc/:vocab", requiresLogin, onlyAdmVox, function(req, res, next) {
      var o;

      o = {
        appname: env.targetapp,
        vocab: req.params.vocab,
        taxon: ""
      };
      return new Taxon(o).save(function(err) {
        if (err) {
          throw err;
        }
        return res.send("OK");
      });
    });
    env.app.post("/add_voc/:vocab/:taxon", requiresLogin, onlyAdmVox, function(req, res, next) {
      var o;

      o = {
        appname: env.targetapp,
        vocab: req.params.vocab,
        taxon: req.params.taxon
      };
      return new Taxon(o).save(function(err) {
        if (err) {
          throw err;
        }
        return res.send("OK");
      });
    });
    env.app.get("/:table/list/:skip", requiresLogin, onlyAdminCanAdminAdmin, function(req, res, next) {
      var o;

      o = {};
      if (req.params.table === "admin") {
        o = {
          appname: env.targetapp
        };
      }
      return req.params.theTable.find(o).limit(20).skip(req.params.skip).exec(function(err, docs) {
        var i, key, val, _ref;

        if (err) {
          throw err;
        }
        for (i in docs) {
          _ref = docs[i]._doc;
          for (key in _ref) {
            if (!__hasProp.call(_ref, key)) continue;
            val = _ref[key];
            if (val && val.getMinutes) {
              docs[i][key].setMinutes(val.getMinutes() - val.getTimezoneOffset());
            }
          }
        }
        return env.respond(req, res, null, null, docs);
      });
    });
    env.app.get("/:table/list/:skip/:field", requiresLogin, onlyAdminCanAdminAdmin, function(req, res, next) {
      return req.params.theTable.find({}).limit(20).skip(req.params.skip).sort(req.params.field).exec(function(err, docs) {
        if (err) {
          throw err;
        }
        return env.respond(req, res, null, null, docs);
      });
    });
    env.app.post("/add_to/:table", requiresLogin, onlyAdminCanAdminAdmin, function(req, res, next) {
      return Fields.find({
        appname: env.targetapp,
        table: req.params.table
      }).exec(function(err, docs) {
        var key, o, val;

        if (err) {
          throw err;
        }
        o = JSON.parse(req.body.obj);
        if (req.params.table === "admin") {
          o.appname = env.targetapp;
        }
        for (key in docs) {
          if (!__hasProp.call(docs, key)) continue;
          val = docs[key];
          if (val.name === "modified_date" || val.name === "created_date") {
            o[val.name] = new Date();
          }
        }
        return new req.params.theTable(o).save(function(err) {
          if (err) {
            throw err;
          }
          return res.send("OK");
        });
      });
    });
    env.app.post("/update/:table", requiresLogin, onlyAdminCanAdminAdmin, function(req, res, next) {
      return Fields.find({
        appname: env.targetapp,
        table: req.params.table
      }).exec(function(err, docs) {
        var key, o;

        if (err) {
          throw err;
        }
        o = JSON.parse(req.body.obj);
        for (key in docs) {
          if (docs[key].name === "modified_date") {
            o[docs[key].name] = new Date();
          }
        }
        return req.params.theTable.update({
          _id: req.body.id
        }, {
          $set: o
        }, function(err) {
          if (err) {
            throw err;
          }
          return res.send("OK");
        });
      });
    });
    env.app.post("/remove_from/:table", requiresLogin, onlyAdminCanAdminAdmin, function(req, res, next) {
      var ids;

      ids = JSON.parse(req.body.id_array);
      req.params.theTable.remove({
        _id: {
          $in: ids
        }
      }, function(err, docs) {
        if (err) {
          throw err;
        }
      });
      return res.send("OK");
    });
    env.app.post("/update_config/:table", requiresLogin, function(req, res) {
      var thislist;

      if (req.session.user.login !== "admin") {
        console.log("authorisation error for user :");
        console.log(req.session.user);
        return;
      }
      thislist = JSON.parse(req.body.list);
      _.each(thislist, function(item) {
        var id;

        id = item._id;
        delete item._id;
        return Fields.update({
          _id: id
        }, item, function(err, docs) {
          if (err) {
            throw err;
          }
        });
      });
      return res.send("OK");
    });
    env.app.post("/refresh", requiresLogin, function(req, res) {
      if (req.session.user.login !== "admin") {
        console.log("authorisation error for user :");
        console.log(req.session.user);
        return;
      }
      return temptools.configureTemplates(env.targetenv, function() {
        return schemetools.configureDBschema(admdb, env.targetenv, function() {
          return res.send("OK");
        });
      });
    });
    /*
    	# session paths
    */

    env.app.get("/sessions/new", function(req, res) {
      var temps;

      temps = [
        {
          selector: "#maintab",
          filename: "login.htm"
        }
      ];
      return env.respond(req, res, env.basetemps, temps, null);
    });
    env.app.post("/sessions", function(req, res) {
      return authenticate(req.body.login, req.body.password, env.targetapp, function(user) {
        var key, val;

        if (!user) {
          return res.redirect("/sessions/new");
        }
        req.session.user = {};
        for (key in user) {
          if (!__hasProp.call(user, key)) continue;
          val = user[key];
          req.session.user[key] = val;
        }
        return res.redirect("/list");
      });
    });
    env.app.post("/session/end", function(req, res) {
      if (req.session && req.session.destroy) {
        req.session.destroy(function() {});
      }
      req.session = null;
      return res.redirect("/sessions/new");
    });
    /*
    	# upload paths
    */

    env.app.get("/browse/:where", requiresLogin, function(req, res) {
      var topath;

      topath = "" + (process.cwd()) + "/apps/static/public/" + env.targetapp + "/" + (req.param("subdir")) + "/";
      return fs.readdir(topath, function(err, files) {
        if (!files) {
          return env.respond(req, res, null, null, null);
        }
        return statdirlist(topath, files, [], function(stats) {
          return env.respond(req, res, null, null, stats);
        });
      });
    });
    env.app.post("/upload/:where", requiresLogin, function(req, res) {
      var filename, filestream, frompath, topath;

      topath = "" + (process.cwd()) + "/apps/static/public/" + env.targetapp + "/" + (req.param("subdir")) + "/";
      frompath = "/tmp/" + req.params.where + "_";
      filename = req.headers["x-file-name"];
      filestream = new fs.WriteStream(frompath + filename);
      req.addListener("data", function(buff) {
        return filestream.write(buff);
      });
      return req.addListener("end", function() {
        filestream.end();
        return finishFileLoad(frompath + filename, topath + filename, 0, function(to) {
          res.writeHead(200, {
            "content-type": "text/plain",
            "final-filename": to
          });
          return res.end();
        });
      });
    });
    env.app.get("/keys/:table", onlyAdminCanAdminAdmin, function(req, res, next) {
      return Fields.findOne({
        appname: env.targetapp,
        table: req.params.table,
        listed: true
      }).sort("listorder").exec(function(err, doc) {
        if (err) {
          throw err;
        }
        return req.params.theTable.find({}, doc.name).exec(function(err, docs) {
          var idkeys;

          if (err) {
            throw err;
          }
          idkeys = [];
          _.each(docs, function(d) {
            return idkeys.push({
              name: d[doc.name],
              id: d._id
            });
          });
          return env.respond(req, res, null, null, idkeys);
        });
      });
    });
    env.app.get("/", function(req, res, next) {
      var temps;

      temps = [
        {
          selector: "#maintab",
          filename: "login.htm"
        }
      ];
      return env.respond(req, res, env.basetemps, temps, null);
    });
    return env.app.get("/:table", function(req, res, next) {
      if (req.params.table.indexOf(".") > 0) {
        return;
      }
      return Fields.find({
        appname: env.targetapp,
        table: req.params.table
      }).sort("listorder").exec(function(err, docs) {
        if (err) {
          throw err;
        }
        _.each(docs, function(d) {
          delete d.appname;
          return delete d.table;
        });
        return env.respond(req, res, null, null, docs);
      });
    });
  };

}).call(this);

/*
//@ sourceMappingURL=admin_routes.map
*/
