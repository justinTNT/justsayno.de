// Generated by CoffeeScript 1.7.1
(function() {
  var eachTxlate, findFields, mongoose, objTxlate, toStr, translateFields, _,
    __hasProp = {}.hasOwnProperty;

  _ = require("underscore");

  mongoose = require("mongoose");


  /*
   * findFields
   * ==========
   * helper function to extract field names from either
   * a) the schema; or
   * b) a list of simple strings, and optional objects matching fieldname keys to selector.property values
   */

  findFields = function(fields) {
    var f, i, just_fields, key, len;
    len = void 0;
    just_fields = [];
    if (fields) {
      len = fields.length;
      if (len) {
        i = 0;
        while (i < len) {
          f = fields[i];
          if (_.isString(f)) {
            just_fields.push(f);
          } else {
            for (key in f) {
              just_fields.push(key);
            }
          }
          i++;
        }
      } else {
        for (key in fields) {
          just_fields.push(key);
        }
      }
    }
    return just_fields;
  };

  objTxlate = function(doc, fields) {
    var e, key, obj, val;
    obj = {};
    for (key in fields) {
      if (!__hasProp.call(fields, key)) continue;
      val = fields[key];
      if (_.isString(doc)) {
        obj[val] = doc;
      } else if (_.isUndefined(doc[key])) {
        try {
          obj[val] = doc.get(key);
        } catch (_error) {
          e = _error;
          console.log("error getting " + key);
        }
      } else {
        obj[val] = doc[key];
      }
    }
    return obj;
  };

  eachTxlate = function(eachd, fields) {
    var i, len, next_field, next_obj;
    next_obj = {};
    len = void 0;
    if (fields) {
      len = fields.length;
    }
    if (!len) {
      return objTxlate(eachd, fields);
    }
    i = 0;
    while (i < len) {
      next_field = fields[i];
      if (_.isString(next_field)) {
        if (_.isString(eachd)) {
          next_obj[next_field] = eachd;
        } else {
          next_obj[next_field] = eachd[next_field];
        }
      } else {
        _.extend(next_obj, objTxlate(eachd, next_field));
      }
      i++;
    }
    return next_obj;
  };


  /*
   * translateFields
   * ===============
   * helper function to extract field values. Two cases :
   * a) for each field in the schema; copy the field if it is defined
   * b) copy the field if it's a string, or rename it if its mapped in a { fieldname, 'selector[.attribute]' } tupple
   */

  translateFields = function(d, fields) {
    var objs;
    objs = [];
    if (!d) {
      console.log("no documents to translate");
    } else {
      if (!d.length) {
        d = [d];
      }
      d.forEach(function(eachd) {
        if (!fields) {
          if (!_.isString(eachd)) {
            fields = _.keys(eachd);
          }
        }
        return objs.push(eachTxlate(eachd, fields));
      });
    }
    return objs;
  };

  toStr = function(fields) {
    return _.reduce(fields, (function(m, v) {
      var key;
      if (_.isObject(v)) {
        for (key in v) {
          if (m.length) {
            m += " ";
          }
          m += key;
        }
      } else {
        if (m.length) {
          m += " ";
        }
        m += v;
      }
      return m;
    }), "");
  };

  exports.translateFields = translateFields;

  exports.findFields = findFields;

  exports.toStr = toStr;

}).call(this);

//# sourceMappingURL=fieldtools.map
